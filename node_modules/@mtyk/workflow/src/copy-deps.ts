var args = process.argv.slice(2)
const chokidar = require("chokidar")
const path = require("path")
const fsPromises = require("fs/promises")
const fs = require("fs")
const { debounce } = require("lodash")
const md5File = require("md5-file")
const { execSync } = require("child_process")
const { rmSync } = require("fs")
const clean = Array.from(args).join("").indexOf("--clean") >= 0

async function filesAreDifferent(a: string, b: string) {
  try {
    const md5a = await md5File(a)
    const md5b = await md5File(b)
    return md5a !== md5b
  } catch (e) {
    // console.error(e)
    return true
  }
}

/**
 * Two-way sync between projects and local dependencies. Assumes all dependencies
 * are in the same directory, specified by `parentDir`
 */
export default async function copyDeps<D extends string>(options: {
  dependencies: D[]
  dryRun?: boolean
  parentDir: string
  projectLocations: {
    [project: string]: { [depSrc: string]: string }
  }
}) {
  const { dependencies, projectLocations: projectToDepMap, parentDir } = options
  const ignored = ["**/node_modules", "**/.git"]

  let startTime = new Date()

  // When a file within a project changes, propagate changes back to root with rsync
  for (const project in projectToDepMap) {
    const projectPath = path.join(parentDir, project)

    for (const depSrcPath in projectToDepMap[project]) {
      const dep = dependencies.find((dep) => depSrcPath.indexOf(dep) === 0)
      if (!dep) {
        throw new Error(
          `Dependency src path ${depSrcPath} not listed in dependencies`
        )
      }

      const projectDepPath = path.join(
        projectPath,
        projectToDepMap[project][depSrcPath] ?? "",
        dep
      )

      if (clean) {
        console.log(`Removing ${projectDepPath}`)
        rmSync(projectDepPath, { recursive: true, force: true })
      }

      try {
        fs.statSync(projectPath).isDirectory
      } catch (e) {
        console.error(
          `Error watching directory ${projectPath}, are you running from the root directory?`
        )
      }

      chokidar.watch(projectDepPath, { ignored, ignoreInitial: true }).on(
        "all",
        debounce(async (event: any, filePath: string) => {
          if (new Date().getTime() - startTime.getTime() < 2500) {
            // Probs running initial copy
            return
          }

          const depDest = path.join(parentDir, depSrcPath)
          const cmd = `rsync -au "${projectDepPath}/" "${depDest}"`
          console.log(`Running ${cmd}`)
          if (!options.dryRun) {
            execSync(cmd, { stdio: "inherit" })
          }
        }, 1000)
      )
    }
  }

  // When files in dependencies change, propagate changes back to projects
  for (const dependency of dependencies) {
    chokidar
      .watch(
        [
          path.join(parentDir, dependency) + "/**/*.(t|j)s(x)?",
          ...(dependency === "mtyk-frontend"
            ? [path.join(parentDir, "mtyk-frontend", "/**/babel.js")]
            : []),
        ],
        {
          ignored,
        }
      )
      .on("all", async (event: any, filePath: string) => {
        // console.log(event, filePath)

        // Send changes back to each project
        for (const project in projectToDepMap) {
          const thisProjectDepMap = projectToDepMap[project]
          const withExtraPath = Object.keys(thisProjectDepMap).find(
            (depSrcPath) => depSrcPath.indexOf(dependency) === 0
          )!
          const pathForThisDep = thisProjectDepMap[withExtraPath]

          if (typeof pathForThisDep !== "undefined") {
            // If we're copying from an inner folder in this dep, the paths won't match
            // since we're bringing files any number of directories up
            // So to get the destination path, remove the inner folder from source path
            const extraPath = withExtraPath.substr(dependency.length + 1)
            let parentDirRelativePath = filePath.substr(parentDir.length + 1)

            if (extraPath.length) {
              // Remove extra path
              let before = parentDirRelativePath
              parentDirRelativePath = parentDirRelativePath.replace(
                `${dependency}/${extraPath}`,
                dependency
              )
              if (before === parentDirRelativePath) {
                // If the path didn't change, resource must be outside the specified inner folder,
                // so do nothing
                return
              }
            }

            // Replace 'src/' because we want to bring in ts rather than built js for mtyk-frontend
            const projectPath = path.join(
              parentDir,
              project,
              pathForThisDep,
              parentDirRelativePath
            )

            const outFolder = path.dirname(projectPath)

            if (await filesAreDifferent(filePath, projectPath)) {
              if (!options.dryRun) {
                await fsPromises.mkdir(outFolder, { recursive: true })
                await fsPromises.copyFile(filePath, projectPath)
              }
              console.log(`${projectPath} updated`)
            } else {
              // console.log('Files are the same', `${(ourPath, filePath)}`)
            }
          }
        }
      })
  }
}
